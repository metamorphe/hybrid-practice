<!DOCTYPE html>
<html>
	<head>
		<title>Exterior path.</title>
		<script type="text/javascript" src="libs/jquery.min.js"></script>
		<script type="text/javascript" src="libs/paper-full.min.js"></script>
		<script type="text/javascript" src="libs/bootstrap.min.js"></script>
		<script type="text/javascript" src="libs/underscore.js"></script>
		<script type="text/javascript" src="libs/math.js"></script>


		<script type="text/javascript" src="js/artwork.js"></script>
		<script type="text/javascript" src="js/ruler.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"></style>

		<script type="text/javascript">
		 	var nineSegment;
		 	var edgeCount = 0;
		 	var coords = [];
		 	var INTERIOR = -1; var CENTERED = 0; var EXTERIOR = 1;

			$(function(){
				// MAIN FUNCTION
				$('#downloadButton').click(function(){
					console.log("clicked");
					$(this).attr('href', $('#myCanvas')[0].toDataURL("image/png") ).attr('download', 'mymodel.png');
				});
				$('#myCanvas').attr('height', $(window).height());
				$('#myCanvas').attr('width', $(window).width());
	

				paper.install(window);
				paper.setup('myCanvas');			
				//img/nine-segment.svg
				nineSegment = new Artwork("img/testNormal.svg", function(display){
					// display.svg.scaling.y = -1

					runScript(display);
				});
			});
			function runScript(display){
				// TODO: YOUR CODE HERE


				//Declarations
				var diffusers = display.queryPrefix('DIF');
				var leds = display.queryPrefix('NLED');
				var breakout = display.queryPrefix('BO');
				var breakin = display.queryPrefix('BI');
				var circuit_path = display.queryPrefix('CP');
				var art = display.queryPrefix('ART');
				var testShape = display.queryPrefix('TEST');


				// console.log(testShape);
				testShape = extractPaths(testShape)[0];
				// console.log(testShape);

				_.each(testShape.segments, function(i, j){
					// console.log(i.toString());
				});

	
				var all_objects = [diffusers, leds, breakout, breakin, circuit_path, art];
				var select_objects = [diffusers, circuit_path];

				var diffuser_centroid_lst = null;
				// calc_centroids(diffusers);
				
				var diffuser_group = create_group(diffusers);
				// var boundingBox = create_bounding_box(diffuser_group, 1, 13, 1);
				// color_wires(boundingBox, .128, 1.5);

				set_invisible(leds);
				set_invisible(breakout);
				set_invisible(breakin);
				set_invisible(circuit_path);
				set_invisible(art);

				set_appearance(diffusers, .128, Ruler.mm2pts(1.5), 'black');
	

				// extracted = extractPaths(diffusers);
				// var dummy = null;
				// var pathToRtn = extracted[0];
		
				// _.each(extracted, function(path, i){
				// 	if (i == 0) {
				// 		return;
				// 	}
				// 	dummy = pathToRtn;
				// 	pathToRtn = pathToRtn.unite(path);
				// 	dummy.remove();
				// });
				// extracted[0].remove();

				// //Find exterior path and ignore internal paths
				// var maxChild = _.max(pathToRtn.children, function(x){
				// 	return x.length;
				// });
				

				// var maxChildRef = maxChild;
				// pathToRtn.removeChildren();
				// pathToRtn.addChild(maxChildRef);
				// pathToRtn.sendToBack();

				// pathToRtn = maxChild;
				// pathToRtn.strokeColor = 'blue';
				// pathToRtn.strokeWidth = 4;
				// pathToRtn.sendToBack();

			
				// pathToRtn.fillColor = 'null';
				// pathToRtn.visible = true;
				// pathToRtn.bringToFront();

				// //Coloring the main fill
				// var c = pathToRtn.clone();
				// c.strokeWidth = 0;
				// c.fillColor = "purple";
				// c.sendToBack();
				// console.log(pathToRtn);
				// strokeHelper(pathToRtn, 2.5, 'red');


				// var test = strokeHelper(testShape, 2.5, 'red', 0);
				drawStroke(testShape, {
							width: 4, 
							color: 'yellow', 
							alignment: -1
					});


				//Create a stroke over each diffuser
				// _.each(diffuser_group, function(d, i){
				// 	console.log('d is:', d.className);
				// 	var d = extractPaths(d);
				// 	strokeHelper(d, 2.5,'brown');
				// });

				paper.view.zoom = 1.75;
				strokeScaling = false;
				paper.view.update();
			}

			/*Calculate the centroids of objects and return a list of centroid coordinates**/
				function calc_centroids(objects){
					console.log("Cal centroids for", objects.length, "diffusers");
					diffuser_centroid_lst = [];

					//Locate each diffuser
					_.each(objects, function(diffuser){
						diffuser.visible = true;

						//Locate each point on a diffuser & add them
						var calc_centroid = new paper.Point(0,0)
						
						_.each(diffuser.segments, function(seg){
							calc_centroid = calc_centroid.add(new paper.Point(seg.point.x, seg.point.y));
						});

						//Finish centroid calculation
						console.log(diffuser.children[0].children.className);
						calc_centroid = calc_centroid.divide(diffuser.segments.length);
						diffuser_centroid_lst.push(calc_centroid);
						return diffuser_centroid_lst;
					});
				}

				/*Unite a group's children into a new path and return new path*/
				function uniteGroup(path, group) {
						var retPath = path;
						_.each(group.children, function(obj, i) {
							console.log(obj);
							console.log(obj.children[0].className);
						
							var scrapPath = retPath;
							console.log("obj", obj);
							console.log(retPath);
		 					retPath = retPath.unite(obj);

		 					if (scrapPath) {
		 						scrapPath.remove();
		 					} return retPath;
					});
				}


				/*Return Pathes  from group*/
				function extractPaths(group) {
					//map takes in a collection and a function
					//_.map(collection, function(el, i, arr) 
					var data = _.map(group, function(x) {
						// console.log(x);
						if (x.className == 'Group') {
							return extractPaths(x.children);
						} else {
							return x;
						}
					});
					data = _.flatten(data);

					return data;
				}

				function ideas(){

						//TODO: Detect a straight path if same angle as prev
						if ((Math.abs(currAngle - prevAngle) == 0)) {
							lineStartingPoint = true;
						}
						lineStartingPoint = false;

               			//Delete overlaps
               			var canDelete;
               			//if exterior or normal
               			if (stroke_align == 1 || stroke_align == 0) {
               				canDelete = ((path.contains(new paper.Point(curr_x, curr_y))));
						}

               			//if internal then make sure path does not contain it
               			else if (stroke_align == -1) {
               				canDelete = (!(path.contains(new paper.Point(curr_x, curr_y))));
               			} 

						for (j = 0; j < circ.segments.length; j++) {
							var curr_x = circ.segments[j].point.x;
							var curr_y = circ.segments[j].point.y;
							//Current point intersects with the path
							if (canDelete) {
								circ.scaling.x = .1;
								circ.scaling.y = .1;
								// circ.visible = false;
								// console.log('PATH CONTAINS CIRCLE');
								// console.log(i, curr_x, curr_y);
								break;
							}
						}
						// circ.bringToFront();
						circGroup.addChild(circ);
               		}


				// Returns false if any part of the circle is "IN" the path, 
				// where "IN" is relative to the stroke_align
				function isValid(circ, path, stroke_align){
					pts = _.map(circ.segments, function(seg){ return seg.point });
					pts = _.map(pts, function(pt){
						if (stroke_align == INTERIOR)
							return path.contains(pt);
						else if (stroke_align == EXTERIOR)
							return ! path.contains(pt);
						else if (stroke_align == CENTERED)
							return true;
					});
					return pts.length == _.compact(pts).length;
				}

				//Returns true if it detects a corner on the path
				function onCorner(circle_center, stroke_width, path, prevAngle, currAngle){
					if ((Math.abs(currAngle - prevAngle)) > 30) return true;
					else return false;
				}

				function fillSpace(mostRecentValidPoint, circle_center, stroke_color, stroke_width, offset) {
							//Fill in space between most recent valid point and a corner
							if (mostRecentValidPoint != null) {
								var spaceToFill = new Path.Line(mostRecentValidPoint, circle_center);
								spaceToFill.strokeColor = 'white';
								spaceToFill.strokeWidth = stroke_width;
								console.log(spaceToFill);
								spaceToFill = _.range(0, spaceToFill.length, offset);
								console.log(spaceToFill);
							}
				}



				//Utilize a path's segments to draw circles indicating corners
				function drawCorners(path, stroke_width, stroke_align) {
					var points = _.range(0, path.segments.length);

					_.each(points, function(i) {
						var cornerPoint = path.segments[i].point;
						var offset = path.getOffsetOf(cornerPoint);
						var norm = path.getNormalAt(offset);

						//Average two adjacent points to get accurate normal
						var step = .000000001;

						//Edge case for first iteration
						if (i == 0) {
							var preNorm = path.getNormalAt(path.getOffsetOf(path.segments[path.segments.length -1].point));
							console.log('bad offset', offset);
						}
						else var preNorm = path.getNormalAt(offset - step); 
					
							var postNorm = path.getNormalAt(offset + step);

						var prevAngle = preNorm.angle;
						var postAngle = postNorm.angle;
						norm.angle = (prevAngle + postAngle) / 2;

						if (i != 0) norm.length *= -1;
						var radiusVector = norm.clone();
						radiusVector.length = stroke_width * 0.5 * stroke_align;


						//Calculating circle centerpoints
						if (stroke_align != CENTERED) cornerPoint = cornerPoint.add(radiusVector);
						

						//Drawing circle
						edgeCircle = new Path.Circle({
		                    center: cornerPoint,
		                    radius: stroke_width / 2 ,
		                    fillColor: 'yellow',
		                    strokeColor: 'yellow',
		                    selected: false
               				});
					});
				}

				//Utilize a path's segments to draw circles indicating corners
				function calculateAllPoints(path) {
					console.log(path.curves);
					var allPoints = [];
					var points = _.range(0, path.segments.length);

					//Saving offsets of each segment point
					_.each(points, function(i) {
						var p = path.segments[i].point;
						var segPoint = path.getOffsetOf(p);
						console.log('segPoint', segPoint);
						allPoints.push(segPoint);
					});

					// 	edgeCircle = new Path.Circle({
		   //                  center: c,
		   //                  radius: stroke_width / 2 ,
		   //                  fillColor: 'white',
		   //                  strokeColor: 'white',
		   //                  selected: false
     //           				});
					// });
				}


				/*Calculate best fit stroke width via a series of small circles.
				Three types based on stroke_align: interior, normal, or exterior*/
				function strokeHelper(path, stroke_width, stroke_color, stroke_align){
					var groupToRtn;

					var circ;
					var point = null;
					var circGroup = new paper.Group();
					var length = path.length;
					var offset = .5; //.2;
					var setRadius = stroke_width / 2;


					//TODO: turn straight lines into rectangles
					// calculateAllPoints(path);

					var lineStartingPoint = path.getPointAt(0);
					var lineEndingPoint = null;

					var prevAngle = 0; var currAngle = 0; var nextAngle = 0; var circle_center;
					var mostRecentValidPoint = null;


					var points = _.range(0, length, offset);
					_.each(points, function(i) {

						var point = path.getPointAt(i);
						var norm = path.getNormalAt(i);
						var tan = path.getTangentAt(i);

						//For edge detection
						currAngle = norm.angle;
						
						norm.length *= -1;
						var radiusVector = norm.clone();
						radiusVector.length = setRadius * stroke_align;

						//Calculating circle centerpoints
						var circle_center = point;
						if (stroke_align != CENTERED) circle_center = point.add(radiusVector);

						//Instantiating circles
						circ = new Path.Circle({
		                    center: circle_center,
		                    radius: setRadius,
		                    fillColor: stroke_color,
		                    strokeColor: stroke_color,
		                    visible: true
               			});

               			var valid = isValid(circ, path, stroke_align);
               			if (!valid && stroke_align != EXTERIOR) circ.remove();

               		

						//TODO: analyze Math.abs(path.getCurvatureAt(i))
               			


						

      					// fillSpace(mostRecentValidPoint, circle_center, stroke_color, stroke_width, offset);
						// 	edgeCount += 1; console.log('corner found', circle_center);
						// }

						prevAngle = currAngle;
					});
					console.log(coords);
					drawCorners(path, stroke_width, stroke_align);

				}

				function visualizeNormal(origin, normal, tangent){
					var lineLength = 50;
					normal = normal.clone();
					tangent = tangent.clone();
					normal.length = lineLength;
					tangent.length = lineLength;


					new paper.Path.Line({
							from: origin, 
							to: origin.add(normal),
							strokeColor: "yellow", 
							strokeWidth: 0.5,
							dashArray: [1, 0.5]
					});

					normal = normal.clone().multiply(-1);
					new paper.Path.Line({
							from: origin, 
							to: origin.add(normal),
							strokeColor: "purple", 
							strokeWidth: 0.5
					});

					new paper.Path.Line({
							from: origin, 
							to: origin.add(tangent.clone().multiply(1)),
							strokeColor: "white",
							strokeWidth: 1
					});
					new paper.Path.Line({
							from: origin, 
							to: origin.add(tangent.clone().multiply(-1)),
							strokeColor: "white", 
							strokeWidth: 1
					});

					// var wayward = new paper.Point(0, 1);
					// wayward.angle = r.direction;

					// new paper.Path.Line({
					// 		from: origin, 
					// 		to: origin.add(wayward.multiply(lineLength * 2)),
					// 		strokeColor: "red", 
					// 		dashArray: [2,1],
					// 		strokeWidth: 0.5
					// });
				}

				function drawStroke(path, stroke_options){
					// Attribute alignment (-1 = interior, 0 = centered, 1 = exterior)
					strokeHelper(path, stroke_options.width, stroke_options.color, stroke_options.alignment);

					if (stroke_options.alignment == EXTERIOR) {
						var shape = new Group({
						    children: [path],
						});
						shape.bringToFront();
					}
				}
			

				/*Flip objects on x-axis and/or y-axis based upon arguments--either 1 or -1.*/
				function flip_on_axis(objects, flip_x, flip_y){
					var objects = _.flatten(objects);
					objects = new paper.Group({
						children: objects,
						scaling: new paper.Size(flip_x, flip_y)
					});
				}

				function create_group(diffusers) { return new paper.Group(diffusers);}


				function create_bounding_box(group, color_amount, bounds, stroke_width){
					//Create bounding box over entire collection of objects
					var boundingBox = new paper.Path.Rectangle(group.bounds.expand(Ruler.mm2pts(bounds)), 0);
					boundingBox.style = {
						fillColor: new Color(color_amount),
						strokeWidth: stroke_width
						}

					boundingBox.sendToBack(); //bringToFront()
					return boundingBox;
				}
				
				/*Color exterior 1mm wide rectangles holding the wires*/
				function color_wires(boundingBox, color_amount, stroke_width){
					for (var i = 0; i < diffuser_centroid_lst.length; i++) {
						var bound_point = boundingBox.getNearestPoint(diffuser_centroid_lst[i]);
						var wire_line = new paper.Path.Line(diffuser_centroid_lst[i], bound_point);
						wire_line.strokeColor = new paper.Color(color_amount, stroke_width);
						// wire_line.strokeWidth = (Ruler.mm2pts(stroke_width)).toString()
						wire_line.strokeWidth = Ruler.mm2pts(stroke_width);
					}
				}

				function set_invisible(objects) {
					for (var i = 0; i < objects.length; i++){
						var o = objects[i];
						o.visible = false;
					}
				}

				/*Loop through diffusers & set colors*/
				function set_appearance(object, stroke_color, stroke_width, fill_color){
					_.each(object, function(diffuser){
						diffuser.set({
							strokeColor: new paper.Color(stroke_color),
							strokeWidth: stroke_width,
							fillColor: fill_color
						})
					});
				}

				/*Create four identical corner circles with appropriate colors.*/
				function create_corner_circles(boundingBox, radius, stroke_width, fill_color, stroke_color, x_flush,y_flush){

					cornerCircle1 = paper.Path.Circle({
						position: new paper.Point(boundingBox.bounds.topLeft.x + Ruler.mm2pts(x_flush), boundingBox.bounds.topLeft.y + Ruler.mm2pts(y_flush)), 
						fillColor: fill_color,
						strokeColor: stroke_color,
						strokeWidth: Ruler.mm2pts(stroke_width),
						radius: Ruler.mm2pts(radius)
					})
					cornerCircle2 = cornerCircle1.clone();
					cornerCircle2.position = new paper.Point(boundingBox.bounds.topRight.x - Ruler.mm2pts(x_flush), boundingBox.bounds.topRight.y + Ruler.mm2pts(y_flush));

					cornerCircle3 = cornerCircle1.clone();
					cornerCircle3.position = new paper.Point(boundingBox.bounds.bottomLeft.x + Ruler.mm2pts(x_flush), boundingBox.bounds.bottomLeft.y - Ruler.mm2pts(y_flush));

					cornerCircle4 = cornerCircle1.clone();
					cornerCircle4.position = new paper.Point(boundingBox.bounds.bottomRight.x - Ruler.mm2pts(x_flush), boundingBox.bounds.bottomRight.y - Ruler.mm2pts(y_flush));
				}
		</script>
	</head>
	<body>
		<div class="container">
			<canvas id="myCanvas" style="position:absolute" id="canvas"></canvas>
			<a id="downloadButton" class='btn btn-default'> DOWNLOAD </a>
		</div>
	</body>
</html>

<style> 
	#downloadButton{
		position: absolute;
		top: 20px;
		left: 20px;
	}
	body, html{
		margin: 0;
		padding: 0;
		background: gray;
	}
</style>