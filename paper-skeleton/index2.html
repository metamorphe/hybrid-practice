<!DOCTYPE html>
<html>
	<head>
		<title>3D Ship</title>
		<script type="text/javascript" src="libs/jquery.min.js"></script>
		<script type="text/javascript" src="libs/paper-full.min.js"></script>
		<script type="text/javascript" src="libs/bootstrap.min.js"></script>
		<script type="text/javascript" src="libs/underscore.js"></script>
		<script type="text/javascript" src="libs/saveas.min.js"></script>
		<script type="text/javascript" src="js/artwork.js"></script>
		<script type="text/javascript" src="js/ruler.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"></style>

		<script type="text/javascript">
		 	var eld;
		 	var bgPath;
			$(function(){
				// MAIN FUNCTION
				$('#downloadButton').click(function(){
					console.log("clicked");
					$(this).attr('href', $('#myCanvas')[0].toDataURL("image/png") ).attr('download', 'mymodel.png');
				});
				$('#downloadButtonSVG').click(function(){
					console.log("clicked");
					console.log("Exporting file as SVG");
					zoom = 1;
					paper.view.update();
		
					exp = paper.project.exportSVG({ 
						asString: true,
						precision: 5
					});
					saveAs(new Blob([exp], {type:"application/svg+xml"}), "mymodel.svg")
				});
				$('#myCanvas').attr('height', $(window).height());
				$('#myCanvas').attr('width', $(window).width());
	

				paper.install(window);
				paper.setup('myCanvas');

				eld = new Artwork("img/sun_moon.svg", function(display) {
					runScript(display);
				});
			});
				
			function runScript(display){
				POINT_OFFSET = 15;
				POINT_INNER_OFFSET = 1;

				

				function generateNodes(nodes, callbackFN){
					var c = new Artwork("components/APA102C.svg", function(footprint) {
						
						square = footprint.queryPrefix("SMD");
						square[0].remove();

						nodes = _.map(nodes, function(element){ 
							is_breakout = ["BO", "BI"].indexOf(Artwork.getPrefix(element)) != -1;
							
							if(is_breakout){
								rectangle = new Path.Rectangle({
									rectangle: element.bounds, 
									strokeColor: "black", 
									background: "white"
								});
							}
							else{
								var fp = footprint.clone();
								fp.svg.position = element.position;
								rectangle = fp.svg;
							}


							// Establish two circles to help with routing.
							var offset = new paper.Point(POINT_OFFSET, 0);
						
							var entryPoint = new Path.Circle({
								position: rectangle.bounds.leftCenter.clone().subtract(offset), 
								radius: 3, 
								fillColor: "blue"
							});
							var exitPoint = new Path.Circle({
								position: rectangle.bounds.rightCenter.clone().add(offset), 
								radius: 3, 
								fillColor: "blue"
							});

							var in_offset = new paper.Point(POINT_INNER_OFFSET, 0);
							// Establish surface-contact circles for final routing.
							var contactEntryPoint = new Path.Circle({
								position: rectangle.bounds.leftCenter.clone().add(in_offset), 
								radius: 2,
								fillColor: "green"
							});

							var contactExitPoint = new Path.Circle({
								position: rectangle.bounds.rightCenter.clone().subtract(in_offset), 
								radius: 2,
								fillColor: "green"
							});

							var group = new Group([rectangle, entryPoint, exitPoint, contactEntryPoint, contactExitPoint]);

							// group.text = pointText;
							group.rectangle = rectangle;
							group.inputPoint = entryPoint;
							group.outputPoint = exitPoint;
							group.contactInput = contactEntryPoint;
							group.contactOutput = contactExitPoint;
							return group;
						});

						callbackFN(nodes);
						footprint.remove();
					}, true);
				}

				// Function to obtain cost (Path length) from node with two neighbors.
				function cost(node, paths) {
					is_breakout = _.isNull(node.left) || _.isNull(node.right);
					
					breakout_bias = is_breakout ? 10000000: 0;
					if(node.rotation % 45 == 0 ) breakout_bias = 0;

					return breakout_bias + _.reduce(paths, function(memo, path){
						return memo + path.length;
					}, 0);
				};

				THETA_STEP = 1;
				// Helper Function to determine optimal routing.
				function bestCost(node) {
					var cost_table = [];
					var original_rotation = node.rotation;
					for(var theta = 0; theta < 360; theta += THETA_STEP){
						
						node.rotation = theta;
						var neighbors = [];

						if(!_.isNull(node.left))
							neighbors.push([node.left.outputPoint.position, node.inputPoint.position]);
						if(!_.isNull(node.right))
							neighbors.push([node.outputPoint.position, node.right.inputPoint.position]);

						neighbors = _.map(neighbors, function(neighbor){
							return new Path(neighbor[0], neighbor[1])
						});

						cost_table.push({theta: theta, cost: cost(node, neighbors)})
						_.each(neighbors, function(neighbor){ neighbor.remove()});
					}
					node.rotation = original_rotation;
					return _.min(cost_table, function(entry){ return entry.cost });
				}

				// Function to route the rectangles together based on overall cost.
				function route(nodes) {
					OPT_MAX_ITERS = 20;
					EPSILON = 10; 
					difference = Number.MAX_SAFE_INTEGER;
					iters = 0;

					while(difference > EPSILON && iters < OPT_MAX_ITERS){
						result = _.map(nodes, function(node, i){
							return bestCost(node);
						});

						difference = _.reduce(nodes, function(memo, node, i){
							var prev = node.rotation;
							node.rotation = result[i].theta;
							return memo + Math.abs(prev - result[i].theta);
						}, 0);



						paper.view.update();
						iters++;
						console.log("OPT STEP", iters, difference);
					}
				};
				function connect_the_dots(nodes){
					pts = []
					var lines = new paper.Group({name: "TRACE: Trace Expansion"});
					_.each(nodes, function(node, i, arr){
						var neighbors = [];

						if(!_.isNull(node.right))
							neighbors.push([node.contactOutput.position, node.outputPoint.position, node.right.inputPoint.position,node.right.contactInput.position]);
						
						neighbors = _.map(neighbors, function(neighbor, i, arr){
							pts.push(neighbor);
							
							return new paper.Path({
								parent: lines,
								segments: neighbor,
								strokeColor: "blue", 
								strokeWidth: 3
							})
						});
					});
					bgPath = new paper.Path({
						strokeColor: "yellow",
						segments: _.flatten(pts),
						strokeWidth: Ruler.mm2pts(10)
					});
					bgPath.sendToBack();
				}

				function cleanup(nodes){
					var ngroup = new paper.Group(nodes);
					_.each(nodes, function(node){
						node.inputPoint.remove();
						node.outputPoint.remove();
						node.contactInput.remove();
						node.contactOutput.remove();
					});
					
					display.svg.remove();
					paper.view.update();
				}
				function init() {					
					leds = _.sortBy(display.queryPrefix("NLED"), function(led){ return led.lid;});
					nodes = _.flatten([display.queryPrefix("BI"),  leds,  display.queryPrefix("BO")]);
					
					nodes = generateNodes(nodes, function(nodes){
							// linked list
						_.each(nodes, function(node, i, arr){
							node.right = null;
							node.left = null;

							if(i - 1 >= 0) node.left = arr[i - 1];
							if(i + 1 < arr.length) node.right = arr[i + 1];
						});
						
						route(nodes);
						connect_the_dots(nodes);
						cleanup(nodes);
					});
				};
				init();
		};	

				var hitOptions = {
					segments: true,
					stroke: true,
					fill: true,
					tolerance: 10
				}
				var t = new paper.Tool();
				t.selected = [];

				

				function addAnchorPoint(pathReceiver, point){
					var closestPoint = pathReceiver.getNearestPoint(point);
					var location = pathReceiver.getLocationOf(closestPoint);
					var index  = location.curve.segment2.index;
					console.log(index);
					return pathReceiver.insert(index, closestPoint);
				}

				t.onMouseDown = function(event) {

					var hitResult = project.hitTest(event.point, hitOptions);
					

					if (!hitResult)
						console.log("No hits");
						return;
				
					if(hitResult.type == "stroke"){
						console.log("Adding anchor");
						var anchor = addAnchorPoint(hitResult.item, event.point);
						var anchorBG = addAnchorPoint(bgPath, event.point);

						t.selected.push(anchor);
						t.selected.push(anchorBG);
						
					}
					else if (hitResult.type == 'segment') {
						anchor = hitResult.segment;
						var anchorBG = addAnchorPoint(bgPath, event.point);
						t.selected.push(anchor);
						t.selected.push(anchorBG);
					}
					
				};

				t.onMouseDrag = function(event) {
					_.each(t.selected, function(anchor){
						anchor.selected = true;
						anchor.point = anchor.point.add(event.delta);
					});
				};

				t.onMouseUp = function(event){
					_.each(t.selected, function(anchor){
						anchor.selected = false;
					});
					t.selected = [];
				}

			
		</script>
	</head>
	<body>
		<div class="container">
			<canvas id="myCanvas"></canvas>
			<a id="downloadButton" class='btn btn-default'>DOWNLOAD</a>
			<a id="downloadButtonSVG" class='btn btn-default'> DOWNLOAD SVG </a>
		</div>
	</body>
</html>

<style> 
	#downloadButtonSVG{
		position: absolute;
		top: 80px;
		left: 20px;
	}
	#downloadButton{
		position: absolute;
		top: 20px;
		left: 20px;
	}
	#myCanvas{
		position: absolute;
		left: 0;
		top: 0;
	}
	body, html{
		margin: 0;
		padding: 0;
		background: white;
	}
</style>