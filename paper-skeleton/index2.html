<!DOCTYPE html>
<html>
	<head>
		<title>3D Ship</title>
		<script type="text/javascript" src="libs/jquery.min.js"></script>
		<script type="text/javascript" src="libs/paper-full.min.js"></script>
		<script type="text/javascript" src="libs/bootstrap.min.js"></script>
		<script type="text/javascript" src="libs/underscore.js"></script>
		<script type="text/javascript" src="js/artwork.js"></script>
		<script type="text/javascript" src="js/ruler.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"></style>

		<script type="text/javascript">
		 	var nineSegment;
			$(function(){
				// MAIN FUNCTION
				$('#downloadButton').click(function(){
					console.log("clicked");
					$(this).attr('href', $('#myCanvas')[0].toDataURL("image/png") ).attr('download', 'mymodel.png');
				});
				$('#myCanvas').attr('height', $(window).height());
				$('#myCanvas').attr('width', $(window).width());
	

				paper.install(window);
				paper.setup('myCanvas');

				nineSegment = new Artwork("img/nine-segment.svg", function(display) {
					runScript(display);
				});
			});
				
			function runScript(display){
				// Declaring a path array, rectangle array, and group array.
				var pathArray = new Array();
				var rectArray = new Array();
				var groupArray = new Array();

				// Declaring two minimumPaths for routing purposes.
				var minimumInputPath;
				var minimumOutputPath;

				// Accessing the ordered array of LEDs.
				var ledSeg = nineSegment;
				var sortedLedSeg = ledSeg.allLeds;

				// Function to add BreakIn Board.
				function addBreakIn() {
					// Query the breakIn board.
					var breakIn = nineSegment.queryPrefix("BI")[0];

					// Instantiate a rectangle based on the board coordinates.
					var rectangle = new Path.Rectangle(new Point(breakIn.bounds.center.x, breakIn.bounds.center.y), 25);
					rectangle.strokeColor = "black";
					rectArray.push(rectangle);

					// Establish two circles to help with routing.
					var entryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x - 15, rectangle.bounds.leftCenter.y), 2);
					var exitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x + 15, rectangle.bounds.rightCenter.y), 2);
					entryPoint.fillColor = "blue";
					exitPoint.fillColor = "red";

					// Instantiate a pointText to help with labeling.
					var pointText = new PointText(new Point(rectangle.bounds.center.x, rectangle.bounds.center.y));
					pointText.justification = "center";
					pointText.fillColor = "black";
					pointText.content = "BI";
					pointText.fontSize = 10;

					// Establish surface-contact circles for final routing.
					var contactEntryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x, rectangle.bounds.leftCenter.y), 2);
					var contactExitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x, rectangle.bounds.rightCenter.y), 2);
					contactEntryPoint.fillColor = "green";
					contactExitPoint.fillColor = "orange";

					// Add the elements to the group for the routing algorithm.
					var group = new Group([rectangle, entryPoint, exitPoint, contactEntryPoint, contactExitPoint]);
					group.rectangle = rectangle;
					group.inputPoint = entryPoint;
					group.outputPoint = exitPoint;
					group.rightNode = groupArray[0];
					group.contactInput = contactEntryPoint;
					group.contactOutput = contactExitPoint;
					groupArray.push(group);
				};

				// Function to add BreakOut Board.
				function addBreakOut() {
					// Query the breakOut board.
					var breakIn = nineSegment.queryPrefix("BO")[0];

					// Instantiate a rectangle based on the board coordinates.
					var rectangle = new Path.Rectangle(new Point(breakIn.bounds.center.x, breakIn.bounds.center.y), 25);
					rectangle.strokeColor = "black";
					rectArray.push(rectangle);

					// Establish two circles to help with routing.
					var entryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x - 15, rectangle.bounds.leftCenter.y), 2);
					var exitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x + 15, rectangle.bounds.rightCenter.y), 2);
					entryPoint.fillColor = "blue";
					exitPoint.fillColor = "red";

					// Instantiate a pointText to help with labeling.
					var pointText = new PointText(new Point(rectangle.bounds.center.x, rectangle.bounds.center.y));
					pointText.justification = "center";
					pointText.fillColor = "black";
					pointText.content = "BO";
					pointText.fontSize = 10;

					// Establish surface-contact circles for final routing.
					var contactEntryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x, rectangle.bounds.leftCenter.y), 2);
					var contactExitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x, rectangle.bounds.rightCenter.y), 2);
					contactEntryPoint.fillColor = "green";
					contactExitPoint.fillColor = "orange";

					// Add the elements to the group for the routing algorithm.
					var group = new Group([rectangle, entryPoint, exitPoint, contactEntryPoint, contactExitPoint]);
					group.rectangle = rectangle;
					group.inputPoint = entryPoint;
					group.outputPoint = exitPoint;
					group.leftNode = groupArray[groupArray.length - 1];
					group.leftNode.rightNode = group;
					group.contactInput = contactEntryPoint;
					group.contactOutput = contactExitPoint;
					groupArray.push(group);
				};

				// Function to set up rectangles for testing (Includes ascii placement).
				function placeRectangles() {
					for (var i = 0; i < sortedLedSeg.length; i++) {
						// Access the LED from the array.
						var currentElement = sortedLedSeg[i];

						// Instantiate a rectangle based on the LED coordinates.
						var leftX = currentElement.bounds.topLeft.x;
						var leftY = currentElement.bounds.topLeft.y;
						var rectangle = new Path.Rectangle(new Point(leftX, leftY), 14);
						rectangle.strokeColor = "black";
						rectArray.push(rectangle);

						// Instantiate a pointText with the ASCII character.
						var pointText = new PointText(new Point(rectangle.bounds.center.x, rectangle.bounds.center.y));
						pointText.justification = "center";
						pointText.fillColor = 'black';
						pointText.content = "-->";
						pointText.fontSize = 5;

						// Establish two circles to help with routing.
						var entryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x - 15, rectangle.bounds.leftCenter.y), 2);
						var exitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x + 15, rectangle.bounds.rightCenter.y), 2);
						entryPoint.fillColor = "blue";
						exitPoint.fillColor = "red";

						// Establish surface-contact circles for final routing.
						var contactEntryPoint = new Path.Circle(new Point(rectangle.bounds.leftCenter.x, rectangle.bounds.leftCenter.y), 2);
						var contactExitPoint = new Path.Circle(new Point(rectangle.bounds.rightCenter.x, rectangle.bounds.rightCenter.y), 2);
						contactEntryPoint.fillColor = "green";
						contactExitPoint.fillColor = "orange";

						// Order all the elements into a group and push the group into a group array.
						var group = new Group([rectangle, pointText, entryPoint, exitPoint, contactEntryPoint, contactExitPoint]);
						group.rectangle = rectangle;
						group.arrow = pointText;
						group.inputPoint = entryPoint;
						group.outputPoint = exitPoint;
						group.contactInput = contactEntryPoint;
						group.contactOutput = contactExitPoint;
						group.locked = false;
						groupArray.push(group);
					};

					for (var i = 0; i < groupArray.length; i++) {
						var group = groupArray[i];
						if (groupArray[i - 1] != null) {
							group.leftNode = groupArray[i - 1];
						};
						if (groupArray[i + 1] != null) {
							group.rightNode = groupArray[i + 1];
						};
					}
				};

				// Function to obtain cost (Path length) from node with two neighbors.
				function cost(inputPath, outputPath, currentNode) {
					if (inputPath && outputPath) {
						return inputPath.length + outputPath.length;
					} else if (inputPath) {
						return inputPath.length;
					} else if (outputPath) {
						return outputPath.length;
					}
				};

				// Helper Function to determine optimal routing.
				function determineOptimalRoute(currentNode) {
					var rotationFactor = 0;
					var minimumNodeCost = Number.MAX_SAFE_INTEGER;
					if (!currentNode.locked) {
						while (rotationFactor <= 360) {
							currentNode.rotation = rotationFactor;
							if (currentNode.leftNode && currentNode.rightNode) {
								var inputPath = new Path(currentNode.leftNode.outputPoint.position, currentNode.inputPoint.position);
								var outputPath = new Path(currentNode.outputPoint.position, currentNode.rightNode.inputPoint.position);
								var pathCost = cost(inputPath, outputPath, currentNode);
								if (pathCost < minimumNodeCost) {
									minimumNodeCost = pathCost;
									currentNode.minimumNodeCost = pathCost;
									currentNode.minimumRotation = rotationFactor;
								};
								inputPath.removeSegments();
								outputPath.removeSegments();
							} else if (currentNode.leftNode) {
								var inputPath = new Path(currentNode.leftNode.outputPoint.position, currentNode.inputPoint.position);
								var pathCost = cost(inputPath, null, currentNode);
								if (pathCost < minimumNodeCost) {
									minimumNodeCost = pathCost;
									currentNode.minimumNodeCost = pathCost;
									currentNode.minimumRotation = rotationFactor;
								};
								inputPath.removeSegments();
							} else if (currentNode.rightNode) {
								var outputPath = new Path(currentNode.outputPoint.position, currentNode.rightNode.inputPoint.position);
								var pathCost = cost(null, outputPath, currentNode);
								if (pathCost < minimumNodeCost) {
									minimumNodeCost = pathCost;
									currentNode.minimumNodeCost = pathCost;
									currentNode.minimumRotation = rotationFactor;
								};
								outputPath.removeSegments();
							};
							rotationFactor += 1;
						};
					};
				};

				// Function to route the rectangles together based on overall cost.
				function route() {
					var counter = 0;
					for (var i = 0; i < groupArray.length; i++) {
						for (var j = 0; j < groupArray.length; j++) {
							var currentNode = groupArray[j];
							determineOptimalRoute(currentNode);
						};
						var minimumCostNode;
						var minimumCost = Number.MAX_SAFE_INTEGER;
						for (var j = 0; j < groupArray.length; j++) {
							var currentNode = groupArray[j];
							if (currentNode.minimumNodeCost < minimumCost && !currentNode.locked) {
								minimumCostNode = currentNode;
								minimumCost = currentNode.minimumNodeCost;
							};
						};
						minimumCostNode.rotation = minimumCostNode.minimumRotation;
						minimumCostNode.locked = true;
					};
					
					for (var h = 0; h < groupArray.length; h++) {
						var currentNode = groupArray[h];
						if (currentNode.rightNode) {
							var outputPath = new Path(currentNode.outputPoint.position, currentNode.rightNode.inputPoint.position);
							outputPath.add(currentNode.rightNode.contactInput.position);
							outputPath.strokeColor = "blue";
							outputPath.insert(0, currentNode.contactOutput.position);
						};
					};
				};

				// Function that initializes the routing process.
				function initialization() {
					addBreakIn();
					placeRectangles();
					addBreakOut();
					route();
					nineSegment.svg.remove();
				};

				// Call to the initialization function.
				initialization();
			};
		</script>
	</head>
	<body>
		<div class="container">
			<canvas id="myCanvas"></canvas>
			<a id="downloadButton" class='btn btn-default'>DOWNLOAD</a>
		</div>
	</body>
</html>

<style> 
	#downloadButton{
		position: absolute;
		top: 20px;
		left: 20px;
	}
	#myCanvas{
		position: absolute;
		left: 0;
		top: 0;
	}
	body, html{
		margin: 0;
		padding: 0;
		background: white;
	}
</style>