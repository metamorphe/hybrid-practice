<!DOCTYPE html>
<html>
	<head>
		<title>3D Ship</title>
		<script type="text/javascript" src="libs/jquery.min.js"></script>
		<script type="text/javascript" src="libs/paper-full.min.js"></script>
		<script type="text/javascript" src="libs/bootstrap.min.js"></script>
		<script type="text/javascript" src="libs/underscore.js"></script>
		<script type="text/javascript" src="js/artwork.js"></script>
		<script type="text/javascript" src="js/ruler.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"></style>

		<script type="text/javascript">
		 	var eld;
			$(function(){
				// MAIN FUNCTION
				$('#downloadButton').click(function(){
					console.log("clicked");
					$(this).attr('href', $('#myCanvas')[0].toDataURL("image/png") ).attr('download', 'mymodel.png');
				});
				$('#myCanvas').attr('height', $(window).height());
				$('#myCanvas').attr('width', $(window).width());
	

				paper.install(window);
				paper.setup('myCanvas');

				eld = new Artwork("img/sun_moon.svg", function(display) {
					runScript(display);
				});
			});
				
			function runScript(display){
				POINT_OFFSET = 10;

				function generateNode(element){
					var text = "-->";
					text = Artwork.getPrefix(element) == "BO" ? "BO" : text;
					text = Artwork.getPrefix(element) == "BI" ? "BI" : text;

					// Instantiate a rectangle based on the LED coordinates.
					var rectangle = new Path.Rectangle({
						rectangle: element.bounds, 
						strokeColor: "black"
					});

					// Instantiate a pointText with the ASCII character.
					var pointText = new PointText({
						justification: "center", 
						fillColor: "black", 
						content: text, 
						fontSize: 5,
						position: rectangle.bounds.center
					});

					// Establish two circles to help with routing.
					var offset = new paper.Point(POINT_OFFSET, 0);
					
					var entryPoint = new Path.Circle({
						position: rectangle.bounds.leftCenter.clone().subtract(offset), 
						radius: 3, 
						fillColor: "blue"
					});
					var exitPoint = new Path.Circle({
						position: rectangle.bounds.rightCenter.clone().add(offset), 
						radius: 3, 
						fillColor: "blue"
					});

					// Establish surface-contact circles for final routing.
					var contactEntryPoint = new Path.Circle({
						position: rectangle.bounds.leftCenter.clone(), 
						radius: 2,
						fillColor: "green"
					});

					var contactExitPoint = new Path.Circle({
						position: rectangle.bounds.rightCenter.clone(), 
						radius: 2,
						fillColor: "green"
					});


					// Order all the elements into a group and push the group into a group array.
					var group = new Group([rectangle, pointText, entryPoint, exitPoint, contactEntryPoint, contactExitPoint]);

					group.rectangle = rectangle;
					group.arrow = pointText;
					group.inputPoint = entryPoint;
					group.outputPoint = exitPoint;
					group.contactInput = contactEntryPoint;
					group.contactOutput = contactExitPoint;
					group.locked = false;

					return group;
				}

				// Function to obtain cost (Path length) from node with two neighbors.
				function cost(node, paths) {
					is_breakout = _.isNull(node.left) || _.isNull(node.right);
					
					breakout_bias = is_breakout ? 10000000: 0;
					if(node.rotation % 45 == 0 ) breakout_bias = 0;

					return breakout_bias + _.reduce(paths, function(memo, path){
						return memo + path.length;
					}, 0);
				};

				THETA_STEP = 1;
				// Helper Function to determine optimal routing.
				function bestCost(node) {
					var cost_table = [];
					var original_rotation = node.rotation;
					for(var theta = 0; theta < 360; theta += THETA_STEP){
						node.rotation = theta;

						var neighbors = [];

						if(!_.isNull(node.left))
							neighbors.push([node.left.outputPoint.position, node.inputPoint.position]);
						if(!_.isNull(node.right))
							neighbors.push([node.outputPoint.position, node.right.inputPoint.position]);

						neighbors = _.map(neighbors, function(neighbor){
							return new Path(neighbor[0], neighbor[1])
						});

						cost_table.push({theta: theta, cost: cost(node, neighbors)})
						_.each(neighbors, function(neighbor){ neighbor.remove()});
					}
					node.rotation = original_rotation;
					return _.min(cost_table, function(entry){ return entry.cost });
				}

				// Function to route the rectangles together based on overall cost.
				function route(nodes) {
					OPT_MAX_ITERS = 20;
					EPSILON = 10; 
					difference = Number.MAX_SAFE_INTEGER;
					iters = 0;

					while(difference > EPSILON && iters < OPT_MAX_ITERS){
						result = _.map(nodes, function(node, i){
							return bestCost(node);
						});

						difference = _.reduce(nodes, function(memo, node, i){
							var prev = node.rotation;
							node.rotation = result[i].theta;
							return memo + Math.abs(prev - result[i].theta);
						}, 0);

						paper.view.update();
						iters++;
						console.log("OPT STEP", iters, difference);
					}
				};

				function connect_the_dots(nodes){
					
					_.each(nodes, function(node, i, arr){
						var neighbors = [];

						if(!_.isNull(node.left))
							neighbors.push([node.left.contactOutput.position, node.left.outputPoint.position, node.inputPoint.position, node.contactInput.position]);
						
						if(!_.isNull(node.right))
							neighbors.push([node.contactOutput.position, node.outputPoint.position, node.right.inputPoint.position,node.right.contactInput.position]);
						pts = []
						neighbors = _.map(neighbors, function(neighbor){
							// console.log(neighbors)
							pts.push(neighbor)
							return new paper.Path({
								segments: neighbor,
								strokeColor: "yellow", 
								strokeWidth: 3
							})
						});

						var bgPath = new paper.Path({
							strokeColor: "green",
							segments: _.flatten(pts),
							strokeWidth: Ruler.mm2pts(10)
						});
						bgPath.sendToBack();
						

					});
				}

				// Function that initializes the routing process.
				function init() {					
					leds = _.sortBy(display.queryPrefix("NLED"), function(led){ return led.lid;});
					nodes = _.flatten([display.queryPrefix("BI"),  leds,  display.queryPrefix("BO")]);
					nodes = _.map(nodes, function(node){ return generateNode(node)});
					
					// linked list
					_.each(nodes, function(node, i, arr){
						node.right = null;
						node.left = null;

						if(i - 1 >= 0) node.left = arr[i - 1];
						if(i + 1 < arr.length) node.right = arr[i + 1];
					});
					
					route(nodes);
					connect_the_dots(nodes);
					display.svg.remove();
				};

				// Call to the initialization function.
				init();
			};
		</script>
	</head>
	<body>
		<div class="container">
			<canvas id="myCanvas"></canvas>
			<a id="downloadButton" class='btn btn-default'>DOWNLOAD</a>
		</div>
	</body>
</html>

<style> 
	#downloadButton{
		position: absolute;
		top: 20px;
		left: 20px;
	}
	#myCanvas{
		position: absolute;
		left: 0;
		top: 0;
	}
	body, html{
		margin: 0;
		padding: 0;
		background: white;
	}
</style>