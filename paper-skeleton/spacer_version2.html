<!DOCTYPE html>
<html>
	<head>
		<title> Spacer Version 2 </title>
		<script type="text/javascript" src="libs/jquery.min.js"></script>
		<script type="text/javascript" src="libs/paper-full.min.js"></script>
		<script type="text/javascript" src="libs/bootstrap.min.js"></script>
		<script type="text/javascript" src="libs/underscore.js"></script>
		<script type="text/javascript" src="libs/saveas.min.js"></script>

		<script type="text/javascript" src="js/convex.js"></script>
		<script type="text/javascript" src="js/format.js"></script>
		<script type="text/javascript" src="js/grid.js"></script>
		<script type="text/javascript" src="js/hull.js"></script>
		<script type="text/javascript" src="js/intersect.js"></script>

		<script type="text/javascript" src="js/artwork.js"></script>
		<script type="text/javascript" src="js/ruler.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"></style>

		<script type="text/javascript">
		 	var nineSegment;
			$(function(){
				// MAIN FUNCTION
				$('#downloadButtonPNG').click(function(){
					console.log("clicked");
					$(this).attr('href', $('#myCanvas')[0].toDataURL("image/png") ).attr('download', 'mymodel.png');
				});

				$('#downloadButtonSVG').click(function(){
					console.log("clicked");
					console.log("Exporting file as SVG");
					paper.view.zoom = 1;
					paper.view.update();
		
					exp = paper.project.exportSVG({ 
						asString: true,
						precision: 5
					});
					saveAs(new Blob([exp], {type:"application/svg+xml"}), "mymodel.svg")
				});

				$('#myCanvas').attr('height', $(window).height());
				$('#myCanvas').attr('width', $(window).width());

				paper.install(window);
				paper.setup('myCanvas');
				paper.loadCustomLibraries();

				paper.view.zoom = 3;
				nineSegment = new Artwork("img/Test.svg", function(display){
					spacerScript(display);
				});
				
			});
			function spacerScript(display){
				/* Test SVG QUERY
				 */
				BI   = display.queryPrefix('BI');
				BO   = display.queryPrefix('BO');
				CP   = display.queryPrefix('CP');
				NLED = display.queryPrefix('NLED');
				SC   = display.queryPrefix('SC');
				CR   = display.queryPrefix('CR');

				var elements = _.flatten([BI, BO, CP, NLED, SC, CR]);
				var backgroundBox = create_background(elements);
				create_background_holes(backgroundBox);

				// var all_objects = [BI, BO, CP, NLED, SC, CR];
				
				/* Reflect Object */
				// flip_on_axis(all_objects, -1, 1)

				/* Compute the Convex Hull */
				var collection = _.flatten([BI[0], BO[0]]);
				
				_.each(collection, function(el){
					el.calculateOMBB();
					el.ombb.visible = true;
					el.ombb.set({
						fillColor: "yellow"
					});
				});
			}

			// PRIVATE FUNCTIONS
			var WALL_EXPANISION = 13; //mm
			var WALL_WIDTH = 3; //mm
			var BASE_HEIGHT = 0.55; // relative 1.7 (base) /3.1 (wall) mm
			var CHANGE_IN_X_DIR = 8;
			var CHANGE_IN_Y_DIR = 8;

			/* Function takes in DIF object, and creates a bounding box */
			function create_background(elements){
				var elements_group = new paper.Group(elements);
				var backgroundBox = new paper.Path.Rectangle(elements_group.bounds.expand(Ruler.mm2pts(WALL_EXPANISION)), 0);
				backgroundBox.style = {
					fillColor: new paper.Color(BASE_HEIGHT),
					strokeColor: 'white',
					strokeWidth: Ruler.mm2pts(WALL_WIDTH)
				}
				backgroundBox.sendToBack();
				return backgroundBox; 
			}


			/* Function takes in bounds box, and creates the bounding holes */
			function create_background_holes(backgroundBox){
				// Corner Circles 
				cornerCircle1 = paper.Path.Circle({
					position: new paper.Point(backgroundBox.bounds.topLeft.x + Ruler.mm2pts(CHANGE_IN_X_DIR), backgroundBox.bounds.topLeft.y + Ruler.mm2pts(CHANGE_IN_Y_DIR)), 
					fillColor: 'black',
					strokeColor: 'black',
					strokeWidth: Ruler.mm2pts(2),
					radius: Ruler.mm2pts(2.5)
				});

				cornerCircle2 = cornerCircle1.clone();
				cornerCircle2.position =  new paper.Point(backgroundBox.bounds.topRight.x - Ruler.mm2pts(CHANGE_IN_X_DIR), backgroundBox.bounds.topRight.y + Ruler.mm2pts(CHANGE_IN_Y_DIR));

				cornerCircle3 = cornerCircle1.clone();
				cornerCircle3.position = new paper.Point(backgroundBox.bounds.bottomLeft.x + Ruler.mm2pts(CHANGE_IN_X_DIR), backgroundBox.bounds.bottomLeft.y - Ruler.mm2pts(CHANGE_IN_Y_DIR));
				
				cornerCircle4 = cornerCircle1.clone();
				cornerCircle4.position = new paper.Point(backgroundBox.bounds.bottomRight.x - Ruler.mm2pts(CHANGE_IN_X_DIR), backgroundBox.bounds.bottomRight.y - Ruler.mm2pts(CHANGE_IN_Y_DIR));

			}
			function create_LED_holes(led_lights){
				for (var index = 0; index < led_lights.length; index++){
					var led  = led_lights[index]
					led.set({
						fillColor: "black",
						strokeColor: 'black',
						strokeWidth: Ruler.mm2pts(1)
					});
				}
			}



			function create_breakin_hole(breakin, backgroundBox){
				// Making the breakin and breakout visible and black
				breakin[0].visible = true;
				breakin[0].set({
					fillColor: 'black',
				})

				var expanded_rec = expand_breaks(breakin[0],backgroundBox);


				// Breakin Rectangle Path
				console.log(expanded_rec);
				var BI_rec = new paper.Path.Rectangle(expanded_rec);
				BI_rec.set({
					fillColor: 'black',
				});
				return BI_rec;
			}
			
			
			function create_breakout_hole(breakout, backgroundBox){
				breakout[0].visible = true;
				// Setting the color of the breakout
				breakout[0].set({
				fillColor: 'black',
				});
				var expanded_rec = expand_breaks(breakout[0], backgroundBox);

				//Breakout Rectangle Path
				var BO_rec = new paper.Path.Rectangle(breakout[0].bounds);
				BO_rec.set({
					fillColor: 'black'
				});
				return BO_rec;

			}
			function expand_breaks(brio,backgroundBox){
				var break_center = brio.position;
				var closest_to_background = backgroundBox.getNearestPoint(break_center);
				var distance_vector = break_center.subtract(closest_to_background);
				var distance_to_border = distance_vector.length;

				// Computes the direction of vector
				var angle_of_vector = distance_vector.angle;
				/* Possible Angles
				 * 0, 90, 180, -90,
				 */

				if (angle_of_vector == 0){
				 	expand_width = (distance_to_border - brio.bounds.width/2) + WALL_WIDTH;
				 	return brio.bounds.expand(Ruler.mm2pts(expand_width),0);
				}
				else{
					var l = new paper.Path.Line({
						from: break_center,
						to: closest_to_background,
						strokeColor: "yellow",
						strokeWidth: 2
					})
					// console.log(l.length);

				 	expand_height = (distance_to_border - brio.bounds.height/2) + Ruler.mm2pts(WALL_WIDTH)/2;


				 	bb = brio.bounds.expand(0, expand_height);
				 	// console.log("N", l.length, distance_to_border)
				 	bb.center.y += expand_height/2;
				 	// console.log("eh", expand_height, brio.bounds)

				 	// bb = brio.bounds
				 	return bb;
				}
			}

			/*Flip objects on x-axis and/or y-axis based upon arguments--either 1 or -1.*/
			function flip_on_axis(objects, flip_x, flip_y){
				var objects = _.flatten(objects);
				objects = new paper.Group({
					children: objects,
					scaling: new paper.Size(flip_x, flip_y)
				});
			}	

			function get_convex_hull(path_object){
				
				// /* Points of the Path Object */
				var sampled_pts = [];
				for(var index = 0; index < path_object.length; index++) {
					pt = path_object.getPointAt(index)
					sampled_pts.push([ pt.x, pt.y])
				}

				/* Convex Hull Points */
				var convex_points = hull(sampled_pts, 50);
				
				/* Creating Points from [[x1,y1]...[xn,yn]] format */
				var list_convex_points = _.map(convex_points, function(pt){
					return new paper.Point(pt[0], pt[1]);
				});

				var path_of_points = new paper.Path({
					segments: list_convex_points,
					strokeColor: "red", 
					// fillColor: "red", 
					strokeWidth: 2

				});
				return path_of_points;
			}

			function get_OMBB_cost(convex, possible_ombb) {
				/* compute itersecting area & overall area */
				var convex_area = convex.area;
				var intersection_area = possible_ombb.area - convex_area;
				return intersection_area;
			}


			function get_OMBB(convex_hull){
				var degrees_of_rotation = _.range(0,360);
				cost_table = [];

				_.each(degrees_of_rotation, function(angle){
					convex_hull.rotation = angle;
					var possible_ombb = new paper.Path.Rectangle(convex_hull.bounds);
					var cost = get_OMBB_cost(convex_hull, possible_ombb);

					cost_table.push({
						angle: angle, 
						cost: cost
					})
					possible_ombb.remove();
				});

				var best_option = _.min(cost_table, function(result){
					return result.cost;
				});

				convex_hull.rotation = best_option.angle
				OMBB = new paper.Path.Rectangle(convex_hull.bounds.clone());
				
				OMBB.rotation = -best_option.angle;
				convex_hull.rotation = 0;
				OMBB.style = {
					fillColor: 'yellow'
				}
			}		

		</script>
	</head>
	<body>
		<div class="container">
			<canvas id="myCanvas"></canvas>
			<a id="downloadButtonPNG" class='btn btn-default'> DOWNLOAD PNG</a>
			<a id="downloadButtonSVG" class='btn btn-default'> DOWNLOAD SVG </a>
		</div>
	</body>
</html>
<style> 
	#downloadButtonPNG{
		position: absolute;
		top: 20px;
		left: 20px;
	}
	#downloadButtonSVG{
		position: absolute;
		top: 80px;
		left: 20px;
	}
	#myCanvas{
		position: absolute;
		left: 0;
		top: 0;
	}
	body, html{
		margin: 0;
		padding: 0;
		background: grey;
	}
</style>