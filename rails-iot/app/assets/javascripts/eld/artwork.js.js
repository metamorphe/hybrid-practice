// Generated by CoffeeScript 1.12.5
window.Artwork = (function() {
  Artwork.ACTUATORS = function() {
    return CanvasUtil.query(paper.project, {
      prefix: ["NLED", "HEATER", "PUMP"]
    });
  };

  Artwork.ACTUATORS_IN = function(device) {
    return CanvasUtil.query(device, {
      prefix: ["NLED", "HEATER", "PUMP"]
    });
  };

  Artwork.getElements = function() {
    return {
      art: CanvasUtil.queryPrefix('ART'),
      diff: CanvasUtil.queryPrefix('DIF'),
      leds: CanvasUtil.queryPrefix('NLED'),
      bo: CanvasUtil.queryPrefix('BO'),
      bi: CanvasUtil.queryPrefix('BI'),
      cp: CanvasUtil.queryPrefix('CP'),
      dds: CanvasUtil.queryPrefix('DDS'),
      mc: CanvasUtil.queryPrefix("MC"),
      base: CanvasUtil.queryPrefix("BASE"),
      wires: CanvasUtil.queryPrefix("WIRE"),
      rays: CanvasUtil.queryPrefix("RAY"),
      nuts: CanvasUtil.queryPrefix("NUT"),
      gray: CanvasUtil.queryPrefix("DDS"),
      devices: CanvasUtil.queryPrefix("DEVICE")
    };
  };

  function Artwork(file, loadFN1, cloned) {
    this.file = file;
    this.loadFN = loadFN1;
    this.cloned = cloned;
    this.svg = null;
    if (_.isUndefined(this.cloned)) {
      this["import"](this.loadFN);
    } else {
      this.clone();
    }
  }

  Artwork.prototype["import"] = function(loadFN) {
    var scope;
    console.info('ARTWORK: SVG IMPORT');
    scope = this;
    paper.project.importSVG(this.file, function(item) {
      scope.svg = item;
      scope.svg.position = paper.view.center;
      scope.process();
      loadFN(scope.svg);
      if (vm) {
        vm.update();
      }
    });
  };

  Artwork.prototype.clone = function() {
    var cl;
    cl = new Artwork(this.svgPath, this.loadFN, true);
    cl.svg = this.svg.clone();
    return cl;
  };

  Artwork.prototype.process = function() {
    this.AE_style_process();
    return this.orderActuators();
  };

  Artwork.prototype.loadLEDs = function() {
    var key, led_data, name;
    if (fs) {
      name = fs.getName();
    } else {
      name = "NONAME";
    }
    key = ['led', name].join('_');
    if (ws.includes(key)) {
      led_data = JSON.parse(ws.get(key));
      console.log('FETCHING', led_data);
      _.map(led_data, function(data) {
        var led;
        console.log(data);
        led = new paper.Path.Rectangle({
          name: 'NLED: APA102C',
          size: new paper.Size(Ruler.mm2pts(LED_WIDTH), Ruler.mm2pts(LED_WIDTH)),
          strokeColor: 'black',
          strokeWidth: 1,
          opacity: 1.0,
          parent: CanvasUtil.queryPrefix('DEVICE')[0],
          position: paper.view.center
        });
        led.fillColor = new paper.Color(data.colorID);
        led.colorID = new paper.Color(data.colorID);
        led.position = new paper.Point(data.position);
        led.target = data.target;
        if (data.forceTarget) {
          return led.forceTarget = data.forceTarget;
        }
      });
    }
    return paper.view.update();
  };

  Artwork.prototype.AE_style_process = function() {
    var dds_style, diff_style, e, hide, show;
    e = Artwork.getElements();
    show = [e.art, e.diff, e.leds, e.dds, e.base];
    hide = [e.rays, e.cp, e.mc, e.bo, e.bi, e.nuts, e.wires];
    _.each(e.leds, function(led) {
      var style;
      style = {
        fillColor: led.colorID ? led.colorID : "#FFFFFF",
        strokeColor: "black",
        strokeWidth: 1,
        opacity: 1.0
      };
      return led.set(style);
    });
    diff_style = {
      fillColor: "#DFDFDF",
      strokeWidth: 3,
      strokeColor: "black",
      opacity: 1.0
    };
    dds_style = {
      fillColor: "#DFDFDF",
      strokeWidth: 1,
      strokeColor: "black",
      dashArray: [2, 1],
      opacity: 0.5
    };
    CanvasUtil.call(e.diff, 'set', diff_style);
    CanvasUtil.call(e.dds, 'set', dds_style);
    CanvasUtil.set(_.flatten(show), "visible", true);
    return CanvasUtil.set(_.flatten(hide), "visible", false);
  };

  Artwork.prototype.orderActuators = function() {
    var devices;
    devices = CanvasUtil.queryPrefix('DEVICE');
    console.log("DEVICES", devices.length);
    if (devices.length === 0) {
      console.warn("NO DEVICES!");
    }
    return _.each(devices, function(device, i) {
      var actuators, backward, bi, cp, device_id, forward, polarity;
      device_id = CanvasUtil.getName(device);
      device_id = eval(device_id);
      actuators = Artwork.ACTUATORS_IN(device);
      cp = CanvasUtil.query(device, {
        prefix: ['CP']
      });
      bi = CanvasUtil.query(device, {
        prefix: ['BI']
      });
      if (_.isEmpty(actuators)) {
        console.warn("NO ACTUATORS DETECTED");
        return;
      }
      if (_.isEmpty(cp)) {
        console.warn("NO PATH; CAN'T ENUMERATE LEDS");
        return;
      }
      if (_.isEmpty(bi)) {
        console.warn("NO BREAKIN; CAN'T ENUMERATE LEDS");
        return;
      }
      cp = cp[0];
      bi = bi[0];
      forward = cp.firstSegment.point.getDistance(bi.firstSegment.point);
      backward = cp.lastSegment.point.getDistance(bi.firstSegment.point);
      polarity = backward < forward ? -1 : 1;
      _.each(actuators, function(actuator) {
        var cpPoint;
        cpPoint = cp.getNearestPoint(actuator.position);
        actuator.offset = polarity * cp.getOffsetOf(cpPoint);
      });
      actuators = _.sortBy(actuators, 'offset');
      return _.each(actuators, function(actuator, id) {
        actuator.lid = device_id + ":" + id;
        return actuator.device = device_id;
      });
    });
  };

  return Artwork;

})();
