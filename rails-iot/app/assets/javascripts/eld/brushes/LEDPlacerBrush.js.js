// Generated by CoffeeScript 1.12.5
window.LEDPlacerBrush = (function() {
  LEDPlacerBrush.MAX_APA102C_RAY_LENGTH = 25;

  LEDPlacerBrush.RAY_RESOLUTION = 1;

  function LEDPlacerBrush(paper) {
    var hitOptions, scope;
    hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 5
    };
    this.enabled = false;
    this.paper = paper;
    this.name = 'LEDPlacerBrush';
    this.tool = new paper.Tool;
    this.tool.holder = this;
    this.hue_step = 360 / 8;
    this.hue = -this.hue_step;
    scope = this;
    this.selected_stroke = null;
    this.selection = [];
    this.target_selection_mode = false;
    this.prev_style = {};
    this.history = {};
    this.makeLED = function(point, diffs) {
      var led, target;
      led = new paper.Path.Rectangle({
        name: 'NLED: APA102C',
        size: new paper.Size(Ruler.mm2pts(LED_WIDTH), Ruler.mm2pts(LED_WIDTH)),
        position: point,
        fillColor: cp.getCurrentColor(),
        strokeColor: 'black',
        strokeWidth: 1,
        opacity: 1.0,
        parent: CanvasUtil.queryPrefix('ELD')[0]
      });
      target = _.filter(diffs, function(diff) {
        return diff.contains(led.position);
      });
      target = _.min(target, function(t) {
        return t.position.getDistance(led.position);
      });
      led.target = target.id;
      sm.selection.push(target);
      scope.addRays(diffs, led);
      vm.update();
      return led;
    };
    this.removeLED = function(led) {
      var rays;
      rays = CanvasUtil.query(paper.project, {
        prefix: 'RAY',
        originLight: path.id
      });
      CanvasUtil.call(rays, 'remove');
      path.remove();
    };
    this.tool.onMouseDown = function(event) {
      var diffs, forced_diff, hitResult, led, leds, name, norm_diff, path;
      diffs = CanvasUtil.queryPrefix('DIF');
      hitResult = paper.project.hitTest(event.point, hitOptions);
      if (!hitResult) {
        sm.selection = [];
        sm.update();
        return;
      }
      path = hitResult.item;
      name = CanvasUtil.getPrefix(path);
      if (!event.modifiers.shift && !event.event.metaKey && ['NLED'].indexOf(name) === -1) {
        sm.selection = [];
        sm.update();
        return;
      }
      if (event.event.metaKey) {
        if (name === 'NLED') {
          scope.removeLED(path);
          sm.selection = [];
          sm.update();
        } else {
          sm.selection = [];
          led = scope.makeLED(event.point, diffs);
          sm.selection.push(led);
          sm.update();
        }
        return;
      }
      if (scope.target_selection_mode || event.modifiers.shift) {
        console.log('TARGET MODE', name);
        if (sm.currentSelectedLEDs().length === 0) {
          return;
        }
        if (['DDS', 'DIF'].indexOf(name) !== -1) {
          scope.target_selection_mode = false;
          leds = sm.currentSelectedLEDs();
          sm.selection = [];
          _.each(leds, function(led) {
            sm.selection.push(led);
            led.forceTarget = path.id;
          });
          sm.selection.push(path);
          sm.update();
        }
        return;
      }
      if (name === 'NLED') {
        sm.selection = [];
        sm.selection.push(path);
        if (path.forceTarget) {
          forced_diff = CanvasUtil.getIDs([path.forceTarget])[0];
          sm.selection.push(forced_diff);
        } else {
          norm_diff = CanvasUtil.getIDs([path.target])[0];
          sm.selection.push(norm_diff);
        }
        sm.update();
        cc.updatePanel(path.id);
        return;
      }
    };
    this.tool.onMouseMove = function(event) {};
    this.tool.onMouseDrag = function(event) {
      var diffs, drags;
      drags = sm.currentSelectedLEDs();
      diffs = CanvasUtil.queryPrefix('DIF');
      _.each(drags, function(drag) {
        var cdiffs;
        var cdiffs, contained_by, diffusers_in_force_target, forced_diff, in_another_diffuser, main_container, rays;
        drag.position = drag.position.add(event.delta);
        cdiffs = _.flatten([CanvasUtil.queryPrefix('DIF'), CanvasUtil.queryPrefix('DDS')]);
        contained_by = _.filter(cdiffs, function(diff) {
          return diff.contains(drag.position);
        });
        main_container = _.min(contained_by, function(diff) {
          return diff.position.getDistance(drag.position);
        });
        if (drag.forceTarget) {
          forced_diff = CanvasUtil.getIDs([drag.forceTarget])[0];
          if (!forced_diff.contains(drag.position)) {
            diffs = [];
          } else {
            cdiffs = _.flatten([CanvasUtil.queryPrefix('DIF')]);
            diffusers_in_force_target = _.filter(cdiffs, function(diff) {
              return forced_diff.id !== diff.id && !diff.contains(forced_diff.position) && forced_diff.contains(diff.position);
            });
            in_another_diffuser = _.compact(_.map(diffusers_in_force_target, function(diff) {
              return diff.contains(drag.position);
            })).length > 0;
            if (in_another_diffuser) {
              diffs = [];
            } else {
              diffs = _.flatten([forced_diff, diffusers_in_force_target]);
            }
          }
        }
        diffs = _.filter(diffs, function(diff) {
          return diff.contains(drag.position);
        });
        rays = CanvasUtil.query(paper.project, {
          prefix: 'RAY',
          originLight: drag.id
        });
        _.each(rays, function(r) {
          var closestIxT, dir, ixts;
          r.position = r.position.add(event.delta);
          if (diffs.length === 0) {
            r.opacity = 0;
          } else {
            r.opacity = 0.3;
            dir = new paper.Point(1, 0);
            dir.length = Ruler.mm2pts(ViewManager.MAX_APA102C_RAY_LENGTH);
            dir.angle = r.originAngle;
            dir = dir.add(drag.position);
            r.lastSegment.point = dir;
            ixts = CanvasUtil.getIntersections(r, diffs);
            if (ixts.length > 0) {
              closestIxT = _.min(ixts, function(ixt) {
                return ixt.point.getDistance(r.position);
              });
              r.lastSegment.point = closestIxT.point.clone();
            }
          }
        });
      });
    };
    this.tool.onMouseUp = function(event) {
      vm.update();
      sm.update();
    };
    return;
  }

  LEDPlacerBrush.prototype.enable = function() {
    var diffs, leds, scope;
    scope = this;
    diffs = CanvasUtil.queryPrefix('DIF');
    leds = CanvasUtil.queryPrefix('NLED');
    _.each(leds, function(led) {
      scope.addRays(diffs, led);
    });
    paper.view.update();
    this.enabled = true;
    vm.update();
  };

  LEDPlacerBrush.prototype.disable = function() {
    var scope;
    scope = this;
    this.enabled = false;
  };

  LEDPlacerBrush.prototype.update = function() {
    var diffs, leds, scope;
    scope = this;
    diffs = CanvasUtil.queryPrefix('DIF');
    leds = CanvasUtil.queryPrefix('NLED');
    _.each(leds, function(led) {
      scope.addRays(diffs, led);
    });
    paper.view.update();
  };

  LEDPlacerBrush.prototype.clear = function() {};

  LEDPlacerBrush.addRays = function(diffs, led) {
    var fill, led_color, leds, rays, scope, target, was_white;
    scope = this;
    target = _.filter(diffs, function(diff) {
      return diff.contains(led.position);
    });
    target = _.min(target, function(t) {
      return t.position.getDistance(led.position);
    });
    led.target = target.id;
    if (diffs.length === 0) {
      return;
    }
    rays = CanvasUtil.query(paper.project, {
      prefix: 'RAY',
      originLight: led.id
    });
    if (rays.length !== 0) {
      CanvasUtil.set(rays, 'position', led.position.clone());
      CanvasUtil.set(rays, 'strokeColor', led.fillColor);
    } else {
      rays = _.range(-180, 180, LEDPlacerBrush.RAY_RESOLUTION);
      led_color = new paper.Color(1);
      was_white = CanvasUtil.queryPrefix('NLED');
      was_white = was_white.length > 0 && was_white[0].fillColor.equals('#FFFFFF');
      fill = led_color;
      led.set({
        fillColor: fill,
        strokeColor: fill,
        strokeWidth: 1,
        colorID: led.colorID ? led.colorID : led_color
      });
      rays = _.map(rays, function(theta) {
        var closestIxT, ixts, line, point;
        point = new paper.Point(1, 0);
        point.length = Ruler.mm2pts(LEDPlacerBrush.MAX_APA102C_RAY_LENGTH);
        point.angle = theta;
        line = new paper.Path.Line({
          name: 'RAY: Cast',
          from: led.position.clone(),
          to: led.position.clone().add(point),
          strokeColor: led_color,
          strokeWidth: 1,
          strokeScaling: false,
          opacity: 0.2,
          parent: led.parent,
          originLight: led.id,
          originAngle: theta,
          hue: scope.hue
        });
        line.pivot = line.firstSegment.point.clone();
        ixts = CanvasUtil.getIntersections(line, diffs);
        if (ixts.length > 0) {
          closestIxT = _.min(ixts, function(ixt) {
            return ixt.point.getDistance(line.position);
          });
          line.lastSegment.point = closestIxT.point.clone();
        }
        return line;
      });
    }
    leds = CanvasUtil.queryPrefix('NLED');
    _.each(leds, function(led, i) {
      led.bringToFront();
    });
  };

  LEDPlacerBrush.prototype.addRays = function(diffs, led) {
    var fill, led_color, leds, rays, scope, target, was_white;
    scope = this;
    target = _.filter(diffs, function(diff) {
      return diff.contains(led.position);
    });
    target = _.min(target, function(t) {
      return t.position.getDistance(led.position);
    });
    led.target = target.id;
    if (diffs.length === 0) {
      return;
    }
    rays = CanvasUtil.query(paper.project, {
      prefix: 'RAY',
      originLight: led.id
    });
    if (rays.length !== 0) {
      CanvasUtil.set(rays, 'position', led.position.clone());
      CanvasUtil.set(rays, 'strokeColor', led.fillColor);
    } else {
      rays = _.range(-180, 180, LEDPlacerBrush.RAY_RESOLUTION);
      led_color = new paper.Color(cp.getCurrentColor());
      was_white = CanvasUtil.queryPrefix('NLED');
      was_white = was_white.length > 0 && was_white[0].fillColor.equals('#FFFFFF');
      fill = vm.getCurrentView() === 'WHITE_RAYS' || was_white ? '#FFFFFF' : led_color;
      led.set({
        fillColor: fill,
        strokeColor: fill,
        strokeWidth: 1,
        colorID: led.colorID ? led.colorID : led_color
      });
      rays = _.map(rays, function(theta) {
        var closestIxT, ixts, line, point;
        point = new paper.Point(1, 0);
        point.length = Ruler.mm2pts(LEDPlacerBrush.MAX_APA102C_RAY_LENGTH);
        point.angle = theta;
        line = new paper.Path.Line({
          name: 'RAY: Cast',
          from: led.position.clone(),
          to: led.position.clone().add(point),
          strokeColor: led_color,
          strokeWidth: 1,
          strokeScaling: false,
          opacity: 0.2,
          parent: led.parent,
          originLight: led.id,
          originAngle: theta,
          hue: scope.hue
        });
        line.pivot = line.firstSegment.point.clone();
        ixts = CanvasUtil.getIntersections(line, diffs);
        if (ixts.length > 0) {
          closestIxT = _.min(ixts, function(ixt) {
            return ixt.point.getDistance(line.position);
          });
          line.lastSegment.point = closestIxT.point.clone();
        }
        return line;
      });
      if (vm.getCurrentView() === 'WHITE_RAYS') {
        CanvasUtil.set(rays, 'strokeColor', '#FFFFFF');
      }
    }
    leds = CanvasUtil.queryPrefix('NLED');
    _.each(leds, function(led, i) {
      led.bringToFront();
    });
  };

  return LEDPlacerBrush;

})();
