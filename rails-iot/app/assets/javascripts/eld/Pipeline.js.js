// Generated by CoffeeScript 1.12.5
window.GRAY_ON = true;

window.SWATCH_ON = false;

window.MC_MOVE = false;

window.WING_HEIGHT = Ruler.mm2pts(1.5);

window.WING_OFFSET = Ruler.mm2pts(2);

window.NUT_HEIGHT = 2.46;

window.HEAD_HEIGHT = 2.76;

window.BOLT_HEIGHT = 21.17;

window.THREAD_HEIGHT = BOLT_HEIGHT - NUT_HEIGHT - HEAD_HEIGHT;

window.HEAD_RADIUS = 5.58 * 1.1 / 2.0;

window.PEG_RADIUS = 3.0 * 1.3 / 2.0;

window.HEX_RADIUS = 7.6 / 2.0;

window.END_GAP = 1.4125;

window.DIFUSSER_HEIGHT = END_GAP + HEAD_HEIGHT;

window.DIFFUSER_MOLD_HEIGHT = 3.00;

window.REFLECTOR_HEIGHT = 10;

window.SPACER_HEIGHT = 6;

window.BASE_HEIGHT = END_GAP + NUT_HEIGHT;

window.OVERALL_HEIGHT = DIFUSSER_HEIGHT + REFLECTOR_HEIGHT + SPACER_HEIGHT + BASE_HEIGHT;

window.WALL_WIDTH = 3;

window.PEG_PADDING = WALL_WIDTH * 1.2;

window.DIFUSSER_BASE_HEIGHT = 0.641;

window.BASE_EXPANSION = -WALL_WIDTH;

window.RIM_HEIGHT = 0.128;

window.RIM_WIDTH = 1.5;

window.WALL_EXPANISION = BASE_EXPANSION;

window.PCB_HEIGHT = 1;

window.CHANGE_IN_X_DIR = 8;

window.CHANGE_IN_Y_DIR = 8;

window.LED_TOLERANCE = 4.5;

window.MOLD_WALL = 5;

window.MOLD_WALL_SPECIAL = 5;

window.POINT_OFFSET = 5;

window.POINT_INNER_OFFSET = 5;

window.THETA_STEP = 45;

window.THETA_OFFSET = 0.5;

window.OPT_MAX_ITERS = 30;

window.EPSILON = 10;

window.LED_WIDTH = 5;

window.LED_HEIGHT = 1.4;

window.MODEL_TO_GENERATE = 'Reflector';

window.Pipeline = (function() {
  function Pipeline() {}

  Pipeline.getElements = function() {
    return {
      art: CanvasUtil.queryPrefix('ART'),
      diff: CanvasUtil.queryPrefix('DIF'),
      leds: CanvasUtil.queryPrefix('NLED'),
      bo: CanvasUtil.queryPrefix('BO'),
      bi: CanvasUtil.queryPrefix('BI'),
      cp: CanvasUtil.queryPrefix('CP'),
      dds: CanvasUtil.queryPrefix('DDS'),
      mc: CanvasUtil.queryPrefix('MC'),
      base: CanvasUtil.queryPrefix('BASE'),
      wires: CanvasUtil.queryPrefix('WIRE'),
      rays: CanvasUtil.queryPrefix('RAY'),
      nuts: CanvasUtil.queryPrefix('NUT'),
      gray: CanvasUtil.queryPrefix('DDS')
    };
  };

  Pipeline.script = {
    mold: function(display, e) {
      var invisible, result;
      this.adjustLEDs(display, e);
      result = new paper.Group({
        name: 'RESULT: MOLD'
      });
      _.each(e.diff, function(diffuser) {
        var expanded;
        expanded = diffuser.expand({
          strokeAlignment: 'exterior',
          strokeWidth: 1,
          strokeOffset: Ruler.mm2pts(MOLD_WALL_SPECIAL),
          strokeColor: 'black',
          fillColor: 'white',
          joinType: 'miter',
          parent: result
        });
        diffuser.set({
          visible: true,
          fillColor: 'black',
          strokeWidth: 0,
          strokeColor: 'white',
          parent: result
        });
      });
      if (GRAY_ON) {
        console.log('GRAY DETECTED', e.gray.length);
        _.each(e.diff, function(diffuser) {
          var inverse;
          inverse = diffuser.fillColor.clone();
          inverse.brightness = 0.5;
          diffuser.set({
            visible: true,
            fillColor: new paper.Color(0),
            strokeWidth: Ruler.mm2pts(2),
            opacity: 1,
            strokeColor: 'white',
            parent: result
          });
          diffuser.bringToFront();
        });
        _.each(e.gray, function(diffuser) {
          var inverse;
          inverse = diffuser.fillColor.clone();
          inverse.brightness = 0;
          diffuser.set({
            visible: true,
            fillColor: new paper.Color(0.3),
            strokeWidth: 0,
            opacity: 1,
            strokeColor: 'white',
            parent: result
          });
          diffuser.bringToFront();
        });
      }
      invisible = _.compact(_.flatten([e.nuts, e.art, e.leds, e.cp, e.bi, e.bo, e.base, e.mc, e.wires]));
      Pipeline.set_visibility(invisible, false);
      result.scaling = new paper.Size(-1, 1);
      result.name = 'RESULT: DIFFUSER';
      result.model_height = DIFFUSER_MOLD_HEIGHT;
    },
    diffuser: function(display, e) {
      var all, invisible, pegs, result;
      this.adjustLEDs(display, e);
      all = _.flatten([e.leds, e.diff, e.mc, e.base]);
      result = new paper.Group(all);
      _.each(e.diff, function(diffuser) {
        var expanded;
        expanded = diffuser.expand({
          strokeAlignment: 'exterior',
          strokeWidth: 0,
          strokeOffset: Ruler.mm2pts(MOLD_WALL_SPECIAL),
          strokeColor: 'black',
          fillColor: 'white',
          joinType: 'miter',
          parent: result
        });
        diffuser.set({
          visible: true,
          fillColor: new paper.Color(0.2),
          strokeWidth: 0,
          strokeColor: 'white',
          parent: result
        });
      });
      _.each(e.diff, function(diffuser) {
        var expanded;
        expanded = diffuser.expand({
          strokeAlignment: 'interior',
          strokeWidth: 0,
          strokeOffset: Ruler.mm2pts(MOLD_WALL_SPECIAL),
          strokeColor: null,
          fillColor: 'black',
          joinType: 'miter',
          parent: result
        });
      });
      _.each(e.base, function(base) {
        base.strokeWidth = 0;
        base.fillColor = 'white';
      });
      pegs = _.map(e.nuts, function(nut) {
        var bolt, bolt_head;
        bolt_head = Pipeline.create({
          geometry: 'circle',
          position: nut.position,
          radius: HEAD_RADIUS,
          height: (DIFUSSER_HEIGHT - HEAD_HEIGHT) / DIFUSSER_HEIGHT,
          parent: result
        });
        bolt = Pipeline.create({
          geometry: 'circle',
          position: nut.position,
          radius: PEG_RADIUS,
          height: 'black',
          parent: result
        });
      });
      CanvasUtil.call(e.base, 'sendToBack');
      invisible = _.compact(_.flatten([e.nuts, e.mc, e.art, e.dds, e.leds, e.cp, e.bi, e.bo]));
      Pipeline.set_visibility(invisible, false);
      result.name = 'RESULT: DIFFUSER';
      result.model_height = DIFUSSER_HEIGHT;
    },
    reflector: function(display, e) {
      var g, result;
      g = new Generator;
      g.model = 'Reflector';
      g["export"] = 'REFL';
      result = this.makeFromProfile(display, e, g);
      result.name = 'RESULT: DIFFUSER';
      result.model_height = REFLECTOR_HEIGHT;
      _.each(e.leds, function(led) {
        var led_hole;
        led_hole = new paper.Path.Circle({
          fillColor: 'black',
          strokeColor: 'black',
          radius: Ruler.mm2pts(3.523),
          position: led.position,
          strokeWidth: 0,
          parent: result
        });
        led.set({
          fillColor: "black",
          strokeColor: 'black',
          strokeWidth: 0,
          parent: result
        });
        return led.remove();
      });
    },
    makeFromProfile: function(display, e, g, chassis, dome) {
      var all, invisible, model, ramps, removeable, result;
      if (chassis == null) {
        chassis = true;
      }
      if (dome == null) {
        dome = false;
      }
      this.adjustLEDs(display, e);
      all = chassis ? _.flatten([e.base, e.diff, e.leds]) : _.flatten([e.diff]);
      if (SWATCH_ON) {
        model = MODEL_TO_GENERATE;
        e.diff[0].diffuser = 'Planar';
        e.diff[1].diffuser = 'Planar';
        e.diff[2].diffuser = 'Hemisphere';
        e.diff[3].diffuser = 'Cuboid';
      } else {
        _.each(e.diff, function(d) {
          d.diffuser = 'Planar';
        });
        _.each(e.dds, function(d) {
          d.diffuser = 'Planar';
        });
      }
      result = new paper.Group(all);
      _.each(e.base, function(base) {
        base.strokeWidth = 0.01;
        base.strokeColor = 'black';
        base.fillColor = 'white';
      });
      _.each(e.diff, function(diffuser) {
        var expanded;
        if (diffuser.className === 'Group') {
          return;
        }
        expanded = diffuser.expand({
          strokeAlignment: 'exterior',
          strokeWidth: 0,
          strokeOffset: Ruler.mm2pts(MOLD_WALL_SPECIAL),
          strokeColor: 'black',
          fillColor: 'white',
          joinType: 'miter',
          parent: result
        });
        diffuser.set({
          visible: true,
          fillColor: 'black',
          strokeWidth: 0,
          strokeColor: 'white',
          parent: result
        });
      });
      ramps = _.map(e.diff, function(diff) {
        var cache_gradients, dleds, lines, ramp_lines, visible;
        dleds = _.filter(e.leds, function(l) {
          return diff.contains(l.bounds.center);
        });
        if (dleds.length === 0) {
          return;
        }
        lines = interpolation_lines(diff, dleds, visible = false);
        cache_gradients = _.chain(lines).unique(function(l) {
          return l.roundedLength;
        }).map(function(l) {
          g.length = l.roundedLength;
          g.random = false;
          g.diffuser = diff.diffuser;
          return {
            roundedLength: l.roundedLength,
            gradients: g.getGradient(),
            line: l.line,
            pathOrigin: l.pathOrigin
          };
        }).groupBy('roundedLength').value();
        ramp_lines = _.map(lines, function(l, idx) {
          var gradient, length;
          length = l.roundedLength;
          gradient = cache_gradients[length][0].gradients.reflector;
          return {
            ramp: gradient,
            line: l.line,
            origin: l.pathOrigin
          };
        });
        return ramps = rampify(ramp_lines, result);
      });
      removeable = CanvasUtil.query(paper.project, {
        prefix: ['RT', 'RAY', 'PL', 'LS', 'NP']
      });
      CanvasUtil.call(removeable, 'remove');
      invisible = _.compact(_.flatten([e.nuts, e.art, e.bo, e.bi, e.cp, e.mc, e.dds]));
      Pipeline.set_visibility(invisible, false);
      result.extend({
        name: 'RESULT: REFLECTOR',
        model_height: REFLECTOR_HEIGHT
      });
      return result;
    },
    no_lens: function(display, e) {
      var all, backgroundBox, invisible, mc, pegs, result, ws;
      ws = new WebStorage;
      this.adjustLEDs(display, e);
      all = _.flatten([e.diff, e.leds, e.base]);
      result = new paper.Group(all);
      backgroundBox = new paper.Path.Rectangle({
        rectangle: result.bounds.expand(Ruler.mm2pts(MOLD_WALL)),
        fillColor: 'white',
        parent: result
      });
      mc = this.adjustMC(display, e, backgroundBox);
      if (mc) {
        mc.parent = result;
        mc.bringToFront();
      }
      _.each(e.diff, function(diff) {
        diff.set({
          fillColor: 'black',
          strokeWidth: 0
        });
      });
      pegs = Pipeline.create_corner_pegs({
        geometry: 'circle',
        bounds: backgroundBox.strokeBounds,
        radius: PEG_RADIUS,
        padding: PEG_PADDING,
        height: 'black',
        parent: result
      });
      backgroundBox.sendToBack();
      invisible = _.compact(_.flatten([e.nuts, e.art, e.base, e.dds, e.bo, e.bi, e.cp, e.leds]));
      Pipeline.set_visibility(invisible, false);
      result.name = 'RESULT: NO LENS';
      result.model_height = REFLECTOR_HEIGHT;
    },
    spacer: function(display, e) {
      var all, expanded, invisible, mc, pegs, result, ws;
      ws = new WebStorage;
      this.adjustLEDs(display, e);
      all = _.flatten([e.base, e.mc, e.leds]);
      result = new paper.Group(all);
      _.each(e.base, function(base) {
        base.strokeWidth = 0.0;
        base.strokeColor = 'black';
        base.fillColor = 'white';
      });
      expanded = e.base[0].expand({
        strokeAlignment: 'interior',
        strokeWidth: 0,
        strokeOffset: Ruler.mm2pts(MOLD_WALL),
        strokeColor: 'black',
        fillColor: new paper.Color(PCB_HEIGHT / SPACER_HEIGHT),
        joinType: 'miter',
        parent: result
      });
      pegs = _.map(e.nuts, function(nut) {
        var bolt;
        bolt = Pipeline.create({
          geometry: 'circle',
          position: nut.position,
          radius: PEG_RADIUS,
          height: 'black',
          parent: result
        });
      });
      if (MC_MOVE) {
        mc = this.adjustMC(display, e, e.base[0]);
        if (mc) {
          mc.parent = result;
          mc.bringToFront();
        }
      } else {
        e.mc[0].fillColor = 'black';
        e.mc[0].parent = result;
        e.mc[0].bringToFront();
      }
      invisible = _.compact(_.flatten([e.nuts, e.art, e.cp, e.dds, e.bo, e.diff, e.bi, e.wires]));
      _.each(e.leds, function(led) {
        var led_hole;
        led_hole = new paper.Path.Circle({
          fillColor: 'black',
          strokeColor: 'black',
          radius: Ruler.mm2pts(3.523),
          position: led.position,
          strokeWidth: 0,
          parent: result
        });
        led.set({
          fillColor: "black",
          strokeColor: 'black',
          strokeWidth: 0,
          parent: result
        });
        led.remove();
      });
      Pipeline.set_visibility(invisible, false);
      result.scaling = new paper.Size(-1, 1);
      result.name = 'RESULT: SPACER';
      result.model_height = SPACER_HEIGHT;
    },
    circuit: function(display, e) {
      var all, backgroundBox, invisible, leds, mc, nodes, result, ws;
      ws = new WebStorage;
      all = _.flatten([e.base, e.leds, e.diff]);
      result = new paper.Group(all);
      backgroundBox = new paper.Path.Rectangle({
        rectangle: result.bounds.expand(Ruler.mm2pts(MOLD_WALL) - Ruler.mm2pts(WALL_WIDTH)),
        fillColor: new paper.Color(PCB_HEIGHT / SPACER_HEIGHT),
        strokeColor: 'white',
        strokeWidth: Ruler.mm2pts(WALL_WIDTH)
      });
      if (MC_MOVE) {
        mc = this.adjustMC(display, e, e.base[0]);
        if (mc) {
          mc.parent = result;
          mc.bringToFront();
        }
      } else {
        e.mc[0].parent = result;
        e.mc[0].bringToFront();
      }
      backgroundBox.remove();
      leds = _.sortBy(e.leds, function(led) {
        return led.lid;
      });
      nodes = _.flatten([e.bi, leds, e.bo]);
      nodes = CircuitRouting.generateNodes(nodes, function(nodes) {
        var config;
        _.each(nodes, function(node, i, arr) {
          node.right = null;
          node.left = null;
          if (i - 1 >= 0) {
            node.left = arr[i - 1];
          }
          if (i + 1 < arr.length) {
            node.right = arr[i + 1];
          }
        });
        config = CircuitRouting.route(nodes);
        ws.set(fs.open_file, JSON.stringify(config));
        CircuitRouting.connect_the_dots(nodes);
        CircuitRouting.cleanup(nodes, e);
        paper.view.update();
        paper.view.zoom = 1;
      });
      addTool();
      invisible = _.compact(_.flatten([e.base, e.cp]));
      Pipeline.set_visibility(invisible, false);
      paper.view.zoom = 1;
    },
    base: function(display, e) {
      var all, invisible, pegs, result;
      all = _.flatten([e.leds, e.diff, e.mc, e.base]);
      result = new paper.Group(all);
      _.each(e.base, function(base) {
        base.strokeWidth = 0;
        base.fillColor = 'white';
        base.parent = result;
      });
      pegs = _.map(e.nuts, function(nut) {
        var nut;
        var bolt;
        nut = Pipeline.create({
          geometry: 'hex',
          position: nut.position,
          radius: HEX_RADIUS,
          height: END_GAP / BASE_HEIGHT,
          parent: result
        });
        bolt = Pipeline.create({
          geometry: 'circle',
          position: nut.position,
          radius: PEG_RADIUS,
          height: 'black',
          parent: result
        });
      });
      CanvasUtil.call(e.base, 'sendToBack');
      invisible = _.compact(_.flatten([e.art, e.nuts, e.mc, e.leds, e.dds, e.diff, e.cp, e.bo, e.bi]));
      Pipeline.set_visibility(invisible, false);
      result.scaling = new paper.Size(-1, 1);
      result.name = 'RESULT: BASE';
      result.model_height = BASE_HEIGHT;
    },
    adjustMC: function(display, e, backgroundBox, result) {
      var alignment, bi, direction, mc, pl, position;
      if (e.mc.length === 0) {
        return;
      }
      mc = e.mc[0];
      bi = e.bi[0];
      pl = new paper.Group([mc, bi]);
      alignment = [mc.bounds.topCenter, mc.bounds.bottomCenter, mc.bounds.leftCenter, mc.bounds.rightCenter];
      alignment = _.max(alignment, function(pt) {
        return bi.position.getDistance(pt);
      });
      mc.set({
        fillColor: 'black',
        pivot: alignment
      });
      pl.pivot = alignment;
      position = backgroundBox.getNearestPoint(alignment);
      direction = position.subtract(alignment);
      if (backgroundBox.strokeWidth > 0) {
        direction.length = backgroundBox.strokeWidth / 2.0;
        position = position.add(direction);
      }
      pl.position = position;
      return pl;
    },
    adjustLEDs: function(display, e) {
      var config;
      if (ws.includes(display.svgPath)) {
        config = JSON.parse(ws.get(display.svgPath));
      }
      _.each(e.leds, function(led) {
        var rotation;
        if (_.isUndefined(config)) {
          rotation = 0;
        } else {
          rotation = _.findWhere(config, {
            id: led.lid
          });
          if (rotation) {
            rotation = rotation.theta;
          }
        }
        led.set({
          rotation: rotation
        });
      });
    },
    code: function(display, e) {
      var lines;
      console.log("CODE", display);
      lines = _.chain(e.leds).map(function(led) {
        if (led.colorID) {
          return {
            device: parseInt(led.lid.split(':')[0]),
            id: parseInt(led.lid.split(':')[1]),
            color: rgb2hex2(led.colorID.toCanvasStyle())
          };
        } else {
          return {
            device: parseInt(led.lid.split(':')[0]),
            id: parseInt(led.lid.split(':')[1]),
            color: rgb2hex2(led.fillColor.toCanvasStyle())
          };
        }
      }).sortBy(function(line) {
        return line.id;
      }).map(function(line) {
        return 'strip.setPixelColor(' + line.id + ',' + line.color + ');';
      }).value().join('\n');
      editor.setValue("");
      editor.insert("/* " + fs.getName() + '\n');
      editor.insert(" * " + new Date(Date.now()).toLocaleString() + '\n');
      editor.insert(" */ " + '\n');
      editor.insert(lines);
      $('.popout').fadeIn();
    }
  };

  return Pipeline;

})();

Pipeline.set_visibility = function(objects, is_visible) {
  _.each(objects, function(object) {
    object.visible = is_visible;
  });
  paper.view.update();
};

Pipeline.create = function(o) {
  o.radius = Ruler.mm2pts(o.radius);
  if (o.geometry === 'hex') {
    return new Path.RegularPolygon({
      parent: o.parent,
      position: o.position,
      center: [50, 50],
      sides: 6,
      fillColor: o.height,
      radius: o.radius
    });
  } else {
    return new paper.Path.Circle({
      parent: o.parent,
      position: o.position,
      fillColor: o.height,
      radius: o.radius
    });
  }
};


/* Function takes in bounds box, and creates the bounding holes */

Pipeline.create_corner_pegs = function(o) {
  var corners;
  o.radius = Ruler.mm2pts(o.radius);
  o.padding = Ruler.mm2pts(o.padding);
  if (o.geometry !== 'hex') {
    o.bounds = o.bounds.expand(-2 * o.radius - Ruler.mm2pts(HEX_RADIUS) - (2 * o.padding));
  } else {
    o.bounds = o.bounds.expand(-2 * o.radius - (2 * o.padding));
  }
  corners = [o.bounds.topRight, o.bounds.topLeft, o.bounds.bottomLeft, o.bounds.bottomRight];
  corners = _.map(corners, function(corner) {
    var dir;
    dir = o.bounds.center.subtract(corner);
    dir.length = 0;
    if (o.geometry === 'hex') {
      return new Path.RegularPolygon({
        parent: o.parent,
        position: corner.add(dir),
        center: [50, 50],
        sides: 6,
        fillColor: o.height,
        radius: o.radius
      });
    } else {
      return new paper.Path.Circle({
        parent: o.parent,
        position: corner.add(dir),
        fillColor: o.height,
        radius: o.radius
      });
    }
  });
  return corners;
};
